# Convex bodies

Until now, we wrote a very basic impulse based rigid body simulation. However, you probably noticed that it’s lacking a lot of features. The most noticeable is that it only checked collisions with spherical bodies.

In this lesson, we’re going to address this issue. The first few paragraphs will be about developing the Gilbert-Johnson-Keerthi (GJK) algorithm. Which is an elegant and effective algorithm for detecting collisions between convex shapes. Then we’ll discuss how the algorithm can be extended for continuous collision detection with conservative advance.

Also, I want to go ahead and define the term simplex here. A simplex is the simplest geometric shape that can be formed from n+1 points, where n is the number of dimensions. So, in zero dimensions, the simplex is a point. In one dimension, the simplex is a line segment. In two dimensions, it’s a triangle. And in three dimensions it’s a tetrahedron.

## Shapes

### Shape class revisited

There’s a handful of functions that we’ll need to add to the base shape class in order to extend our collision detection to general convex shapes.

```
class Shape
{
public:
	enum class ShapeType
	{
		SHAPE_SPHERE,
		SHAPE_BOX,
		SHAPE_CONVEX
	};
	...
	virtual void Build(const Vec3* pts, const int num) {}
	virtual Vec3 Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) = 0;
	virtual float FastestLinearSpeed(const Vec3& angularVelocity, const Vec3& dir) const { return 0; }

protected:
	Vec3 centerOfMass;
};
```

Notice that we’re only overriding the Support function. That’s because the support function gives us a point on the convex shape that is furthest in a particular direction. While the FastestLinearSpeed is a function that is only useful for non-spherical shapes. The FastestLinearSpeed function is used for continuous collision detection. It’s necessary for objects that are ”long”. Since a ”long” object that’s rotating might hit other objects, even though its linear velocity is zero. And for spheres, we don’t care how quickly they rotate; we only care about their linear velocity. But we’ll get more into this when we cover conservative advance later. So, let’s have a look at the Support function for spheres:

```
Vec3 ShapeSphere::Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias)
{
	return pos + dir * (radius + bias);
}
```

The dir vector is assumed to be normalized. Also, take note of the bias term. This is used to expand or shrink the apparent size of the shape. Which is necessary for accurately calculating the contact normal. But, we’ll discuss it more in a few paragraphs from now.

### Box shape

The first new shape we’re going to implement is the box shape. Boxes are so common in games, therefore we really need to know how to simulate them. It’ll also help ease us into general convex hulls. We can think of boxes as oriented bounds, or we can think of boxes as convex hulls that have eight points defining the corners. We are going to think of them as the latter, since that’ll be a natural way of moving into general convex hulls.

The class declaration is:

```
class ShapeBox : public Shape
{
public:
	ShapeBox(const Vec3* points, const int num)
	{
		Build(points, num);
	}

	ShapeType GetType() const override { return ShapeType::SHAPE_BOX; }
	Mat3 InertiaTensor() const override;
	Bounds GetBounds(const Vec3& pos, const Quat& orient) const override;
	Bounds GetBounds() const override;
	void Build(const Vec3* pts, const int num) override;
	Vec3 Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) override;
	float FastestLinearSpeed(const Vec3& angularVelocity, const Vec3& dir) const override;

	std::vector<Vec3> points;
	Bounds bounds;
};
```
Let’s first have a look at the Build function. This will be where we build the bounds and store the points of the box:

```
void ShapeBox::Build(const Vec3* pts, const int num)
{
	for (int i = 0; i < num; ++i)
	{
		bounds.Expand(pts[i]);
	}

	points.clear();
	points.push_back(Vec3{ bounds.mins.x, bounds.mins.y, bounds.mins.z });
	points.push_back(Vec3{ bounds.maxs .x, bounds.mins.y, bounds.mins.z });
	points.push_back(Vec3{ bounds.mins.x, bounds.maxs.y, bounds.mins.z });
	points.push_back(Vec3{ bounds.mins.x, bounds.mins.y, bounds.maxs.z });

	points.push_back(Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.maxs.z });
	points.push_back(Vec3{ bounds.mins.x, bounds.maxs.y, bounds.maxs.z });
	points.push_back(Vec3{ bounds.maxs.x, bounds.mins.y, bounds.maxs.z });
	points.push_back(Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.mins.z });

	centerOfMass = (bounds.maxs + bounds.mins) * 0.5f;
}
```

The inertia tensor for a box is defined as:

$$
I =
\begin{pmatrix}
1/12 M(h^2 + d^2) & 0 & 0 \\
0 & 1/12 M(w^2 + d^2) & 0 \\
0 & 0 & 1/12 M(h^2 + w^2)
\end{pmatrix}
$$

With h, d, and w the height, depth and width of the box.

However, we can’t guarantee that the box will be centered about the origin. In order to handle them we need to take advantage of the parallel axis theorem. Recall the definition of the inertia tensor is:

$$ I_{ij} \equiv {\sum_{k} m_k \cdot (\vec{r_k} \cdot \vec{r_k} \cdot \delta_{ij} - x_i \cdot x_j)} $$

Where $\vec{r_i}$ is the distance from the center of mass for the sample point mass, $m_i$. And the tensor form of the parallel axis theorem is:

$$ J_{ij} \equiv I_{ij} + M * (|R|^2\delta_{ij} - R_i R_j) $$

Which gives us the code for the InertiaTensor function:
```

Mat3 ShapeBox::InertiaTensor() const
{
	// Inertia tensor for box centered around zero
	const float dx = bounds.maxs.x - bounds.mins.x;
	const float dy = bounds.maxs.y - bounds.mins.y;
	const float dz = bounds.maxs.z - bounds.mins.z;

	Mat3 tensor;
	tensor.Zero();
	tensor.rows[0][0] = (dy * dy + dz * dz) / 12.0f;
	tensor.rows[1][1] = (dx * dx + dz * dz) / 12.0f;
	tensor.rows[2][2] = (dx * dx + dy * dy) / 12.0f;

	// Now we use the parallel axis theorem to get the inertia
	// tensor for a box that is not centered around the origin

	Vec3 cm;
	cm.x = (bounds.maxs.x + bounds.mins.x) * 0.5f;
	cm.y = (bounds.maxs.y + bounds.mins.y) * 0.5f;
	cm.z = (bounds.maxs.z + bounds.mins.z) * 0.5f;

	// Displacement of the center of mass from origin
	const Vec3 R = Vec3{ 0, 0, 0 } - cm;
	const float R2 = R.GetLengthSqr();

	Mat3 patTensor;
	patTensor.rows[0] = Vec3{ R2 - R.x * R.x, R.x * R.y, R.x * R.z };
	patTensor.rows[1] = Vec3{ R.y * R.x, R2 - R.y * R.y, R.y * R.z };
	patTensor.rows[2] = Vec3{ R.z * R.x, R.z * R.y, R2 - R.z * R.z };

	// Now we need to add the center of mass tensor and the parallel axis
	// theorem tensor together:
	tensor += patTensor;
	return tensor;
}
```

Next let’s have a look at the support function. Remember, the support function only takes in a direction, and returns the vertex on the shape that is furthest in that direction. We can make a pretty simple brute force version of that for our boxes like so:
```
Vec3 ShapeBox::Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias)
{
	// Find the point in furthest direction
	Vec3 maxPt = orient.RotatePoint(points[0]) + pos;
	float maxDist = dir.Dot(maxPt);
	for (int i = 1; i < points.size(); i++) {
		const Vec3 pt = orient.RotatePoint(points[i]) + pos;
		const float dist = dir.Dot(pt);

		if (dist > maxDist) {
			maxDist = dist;
			maxPt = pt;
		}
	}

	Vec3 norm = dir;
	norm.Normalize();
	norm *= bias;
	return maxPt + norm;
}
```

Of course we’re going to need the bounds functions for use in the broadphase. This is also a very straightforward method:
```
Bounds ShapeBox::GetBounds(const Vec3& pos, const Quat& orient) const
{
	Vec3 corners[8];
	corners[0] = Vec3{ bounds.mins.x, bounds.mins.y, bounds.mins.z };
	corners[1] = Vec3{ bounds.mins.x, bounds.mins.y, bounds.maxs.z };
	corners[2] = Vec3{ bounds.mins.x, bounds.maxs.y, bounds.mins.z };
	corners[3] = Vec3{ bounds.maxs.x, bounds.mins.y, bounds.mins.z };

	corners[4] = Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.maxs.z };
	corners[5] = Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.mins.z };
	corners[6] = Vec3{ bounds.maxs.x, bounds.mins.y, bounds.maxs.z };
	corners[7] = Vec3{ bounds.mins.x, bounds.maxs.y, bounds.maxs.z };

	Bounds expandedBounds;
	for (int i = 0; i < 8; ++i) {
		corners[i] = orient.RotatePoint(corners[i]) + pos;
		expandedBounds.Expand(corners[i]);
	}
	return expandedBounds;
}

Bounds ShapeBox::GetBounds() const
{
	return bounds;
}
```

And now the FastestLinearSpeed function. As we mentioned in the previous lesson, this is going to be  used for continuous collision detection. And it takes in a direction and the angular velocity of the object and  returns to us the velocity of the vertex traveling the fastest in that direction.
```
float ShapeBox::FastestLinearSpeed(const Vec3& angularVelocity, const Vec3& dir) const
{
	float maxSpeed{ 0 };
	for (int i = 1; i < points.size(); i++) {
		Vec3 r = points[i] - centerOfMass;
		Vec3 linearVelocity = angularVelocity.Cross(r);
		float speed = dir.Dot(linearVelocity);
		if (speed > maxSpeed) {
			maxSpeed = speed;
		}
	}
	return maxSpeed;
}
```

### Convex hull

If we want to start modeling bodies that are more complicated than spheres and boxes then we need to figure out how to collide general convex shapes. Technically a convex hull is the intersection of a set of infinite half spaces. But for our needs it’ll just be an array of points. And it’s going to be pretty easy to add this shape to the code, since we already have a base shape class:

`Shape.h`
```
class ShapeConvex : public Shape {
public:
	explicit ShapeConvex(const Vec3* pts, const int num) {
		Build(pts, num);
	}

	void Build(const Vec3* pts, const int num) override;
	Vec3 Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) const override;
	Mat3 InertiaTensor() const override;
	float FastestLinearSpeed(const Vec3& angularVelocity, const Vec3& dir) const override;

	Bounds GetBounds(const Vec3& pos, const Quat& orient) const override;
	Bounds GetBounds() const override;
	ShapeType GetType() const override { return ShapeType::SHAPE_CONVEX; }

	std::vector<Vec3> points;
	Bounds bounds;
	Mat3 inertiaTensor;
};
```

`Shape.cpp`
```
Bounds ShapeConvex::GetBounds(const Vec3& pos, const Quat& orient) const
{
	Vec3 corners[8];
	corners[0] = Vec3{ bounds.mins.x, bounds.mins.y, bounds.mins.z };
	corners[1] = Vec3{ bounds.mins.x, bounds.mins.y, bounds.maxs.z };
	corners[2] = Vec3{ bounds.mins.x, bounds.maxs.y, bounds.mins.z };
	corners[3] = Vec3{ bounds.maxs.x, bounds.mins.y, bounds.mins.z };

	corners[4] = Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.maxs.z };
	corners[5] = Vec3{ bounds.maxs.x, bounds.maxs.y, bounds.mins.z };
	corners[6] = Vec3{ bounds.maxs.x, bounds.mins.y, bounds.maxs.z };
	corners[7] = Vec3{ bounds.mins.x, bounds.maxs.y, bounds.maxs.z };

	Bounds expandedBounds;
	for (int i = 0; i < 8; ++i) {
		corners[i] = orient.RotatePoint(corners[i]) + pos;
		expandedBounds.Expand(corners[i]);
	}
	return expandedBounds;
}

Bounds ShapeConvex::GetBounds() const
{
	return bounds;
}

Mat3 ShapeConvex::InertiaTensor() const
{
	return inertiaTensor;
}

Vec3 ShapeConvex::Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) const
{
	// Empty for now
}

float ShapeConvex::FastestLinearSpeed(const Vec3& angularVelocity, const Vec3& dir) const
{
	float maxSpeed{ 0 };
	for (int i = 1; i < points.size(); i++) {
		Vec3 r = points[i] - centerOfMass;
		Vec3 linearVelocity = angularVelocity.Cross(r);
		float speed = dir.Dot(linearVelocity);
		if (speed > maxSpeed) {
			maxSpeed = speed;
		}
	}
	return maxSpeed;
}
```

Now, you might think that the Build function for this class should be pretty simple. After all, we’re just going to pass in an array of points and store an array of points, so can’t we just copy it and that’s it? Unfortunately, it’s not that simple. Because we also need to construct the inertia tensor. And, we need to be certain that the only points we store, are points that are on the surface of the convex hull. So how do we do all this?

Well, we basically have to slowly build up connections of the points. If any points are found to be inside the convex hull, then they’re discarded. We can do this by building a simplex (tetrahedron) and then expanding it out to include all the points that are outside of it. To build the tetrahedron we take four basic steps:
1. Find a point that is the furthest in a particular direction (later we will call this a support point)
2. Find another point that is furthest in the opposite direction of the point from step 1
3. Find a third point that is furthest from the axis of the points formed from 1 & 2
4. Then we find the point that is furthest from the plane formed from the previous points
5. Finally, we build the “connections” of those points. But really, we’re just recording triangle indices.

In order to achieve that, we'll create a `ShapeUtils.h` function collection:

`ShapeUtils.h`
```
#pragma once
#include "code/Math/Vector.h"
#include <vector>

struct Tri {
	int a;
	int b;
	int c;
};

struct Edge {
	int a;
	int b;

	bool operator == (const Edge& rhs) const {
		return ((a == rhs.a && b == rhs.b) || (a == rhs.b && b == rhs.a));
	}
};

int FindPointFurthestInDir(const Vec3* pts, const int num, const Vec3& dir);

float DistanceFromLine(const Vec3& a, const Vec3& b, const Vec3& pt);

Vec3 FindPointFurthestFromLine(const Vec3* pts, const int num, const Vec3& ptA, const Vec3& ptB);

float DistanceFromTriangle(const Vec3& a, const Vec3& b, const Vec3& c, const Vec3& pt);

Vec3 FindPointFurthestFromTriangle(const Vec3* pts, const int num, const Vec3& ptA, const Vec3& ptB, const Vec3& ptC);

void BuildTetrahedron(const Vec3* verts, const int num, std::vector<Vec3>& hullPts, std::vector<Tri>& hullTris);

void RemoveInternalPoints(const std::vector<Vec3>& hullPoints, const std::vector<Tri>& hullTris, std::vector<Vec3>& checkPts);

bool IsEdgeUnique(const std::vector<Tri>& tris, const std::vector<int>& facingTris, const int ignoreTri, const Edge& edge);

void AddPoint(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris, const Vec3& pt);

void RemoveUnreferencedVerts(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris);

void ExpandConvexHull(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris, const std::vector<Vec3>& verts);

bool IsExternal(const std::vector<Vec3>& pts, const std::vector<Tri>& tris, const Vec3& pt);

void BuildConvexHull(
	const std::vector<Vec3>& verts,
	std::vector<Vec3>& hullPts,
	std::vector<Tri>& hullTris
);
```

`ShapeUtils.cpp`
```
#pragma once
#include "ShapeUtils.h"

int FindPointFurthestInDir(const Vec3* pts, const int num, const Vec3& dir)
{
	int maxIndex = 0;
	float maxDist = dir.Dot(pts[0]);
	for (int i = 1; i < num; i++) {
		float dist = dir.Dot(pts[i]);
		if (dist > maxDist) {
			maxDist = dist;
			maxIndex = i;
		}
	}
	return maxIndex;
}

float DistanceFromLine(const Vec3& a, const Vec3& b, const Vec3& pt)
{
	Vec3 ab = b - a;
	ab.Normalize();

	Vec3 ray = pt - a;
	Vec3 projectionOnAB = ab * ray.Dot(ab);
	Vec3 perpindicular = ray - projectionOnAB;
	return perpindicular.GetMagnitude();
}

Vec3 FindPointFurthestFromLine(const Vec3* pts, const int num, const Vec3& ptA, const Vec3& ptB)
{
	int maxIdx = 0;
	float maxDist = DistanceFromLine(ptA, ptB, pts[0]);
	for (int i = 1; i < num; i++) {
		float dist = DistanceFromLine(ptA, ptB, pts[i]);
		if (dist > maxDist) {
			maxDist = dist;
			maxIdx = i;
		}
	}
	return pts[maxIdx];
}

float DistanceFromTriangle(const Vec3& a, const Vec3& b, const Vec3& c, const Vec3& pt)
{
	Vec3 ab = b - a;
	Vec3 ac = c - a;
	Vec3 normal = ab.Cross(ac);
	normal.Normalize();

	Vec3 ray = pt - a;
	float dist = ray.Dot(normal);
	return dist;
}

Vec3 FindPointFurthestFromTriangle(const Vec3* pts, const int num, const Vec3& ptA, const Vec3& ptB, const Vec3& ptC)
{
	int maxIdx = 0;
	float maxDist = DistanceFromTriangle(ptA, ptB, ptC, pts[0]);
	for (int i = 1; i < num; i++) {
		float dist = DistanceFromTriangle(ptA, ptB, ptC, pts[i]);
		if (dist * dist > maxDist * maxDist) {
			maxDist = dist;
			maxIdx = i;
		}
	}
	return pts[maxIdx];
}

struct Tri {
	int a;
	int b;
	int c;
};

struct Edge {
	int a;
	int b;

	bool operator == (const Edge& rhs) const {
		return ((a == rhs.a && b == rhs.b) || (a == rhs.b && b == rhs.a));
	}
};

void BuildTetrahedron(const Vec3* verts, const int num, std::vector<Vec3>& hullPts, std::vector<Tri>& hullTris) {
	hullPts.clear();
	hullTris.clear();

	Vec3 points[4];

	int idx = FindPointFurthestInDir(verts, num, Vec3(1, 0, 0));
	points[0] = verts[idx];
	idx = FindPointFurthestInDir(verts, num, points[0] * -1.0f);
	points[1] = verts[idx];
	points[2] = FindPointFurthestFromLine(verts, num, points[0], points[1]);
	points[3] = FindPointFurthestFromTriangle(verts, num, points[0], points[1], points[2]);

	// This is important for making sure the ordering is CCW for all faces.
	float dist = DistanceFromTriangle(points[0], points[1], points[2], points[3]);
	if (dist > 0.0f) {
		std::swap(points[0], points[1]);
	}

	// Build the tetrahedron
	hullPts.push_back(points[0]);
	hullPts.push_back(points[1]);
	hullPts.push_back(points[2]);
	hullPts.push_back(points[3]);

	hullTris.push_back(Tri{ 0, 1, 2 });
	hullTris.push_back(Tri{ 0, 2, 3 });
	hullTris.push_back(Tri{ 2, 1, 3 });
	hullTris.push_back(Tri{ 1, 0, 3 });
}
```
Note that we need to make sure that every face of the tetrahedron is in counterclockwise order (CCW), since we’ll use that to calculate the normals of each face, and our convex shapes have outward facing normals.

So, now that we have the most basic convex hull possible (a tetrahedron). We need to expand it out to include all the other points that define the surface of the shape. Here’s an outline of the steps that we need to perform to expand the tetrahedron to the convex hull:
1. Remove any internal points. There may be some points that are already inside the tetrahedron, so we need to discard them, since we only want the points that are on the surface of the convex hull.
2. Then we choose any point that is still external to the hull, and find the point furthest in that direction.
3. Then we find all the triangles that face this point and discard them.
4. Find the dangling edges, and use them to create new triangles.
5. Go back to step 1 and repeat until there are no external points.
6. Remove any points that are not referenced by any triangles.

Here is the function to to that:

`ShapeUtils.cpp`
```
void ExpandConvexHull(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris, const std::vector<Vec3>& verts)
{
	std::vector< Vec3 > externalVerts = verts;
	RemoveInternalPoints(hullPoints, hullTris, externalVerts);

	while (externalVerts.size() > 0) {
		int ptIdx = FindPointFurthestInDir(externalVerts.data(), (int)externalVerts.size(), externalVerts[0]);

		Vec3 pt = externalVerts[ptIdx];

		// Remove this element
		externalVerts.erase(externalVerts.begin() + ptIdx);

		AddPoint(hullPoints, hullTris, pt);

		RemoveInternalPoints(hullPoints, hullTris, externalVerts);
	}

	RemoveUnreferencedVerts(hullPoints, hullTris);
}
```

To execute this function, we need other functions. Let’s start with the RemoveInternalPoints. This is pretty brute force, we will just iterate through the “externalVerts” list and check if any of them are inside the current convex hull. If a point is inside the hull, then we will remove it from the list:

`ShapeUtils.cpp`
```
void RemoveInternalPoints(const std::vector<Vec3>& hullPoints, const std::vector<Tri>& hullTris, std::vector<Vec3>& checkPts)
{
	for (int i = 0; i < checkPts.size(); i++) {
		const Vec3& pt = checkPts[i];

		bool isExternal = false;
		for (int t = 0; t < hullTris.size(); t++) {
			const Tri& tri = hullTris[t];
			const Vec3& a = hullPoints[tri.a];
			const Vec3& b = hullPoints[tri.b];
			const Vec3& c = hullPoints[tri.c];

			// If the point is in front of any triangle then it's external
			float dist = DistanceFromTriangle(a, b, c, pt);
			if (dist > 0.0f) {
				isExternal = true;
				break;
			}
		}

		// If it's not external, then it's inside the polyhedron and should be removed
		if (!isExternal) {
			checkPts.erase(checkPts.begin() + i);
			i--;
		}
	}

	// Also remove any points that are just a little too close to the hull points
	for (int i = 0; i < checkPts.size(); i++) {
		const Vec3& pt = checkPts[i];

		bool isTooClose = false;
		for (int j = 0; j < hullPoints.size(); j++) {
			Vec3 hullPt = hullPoints[j];
			Vec3 ray = hullPt - pt;
			// 1cm is too close
			if (ray.GetLengthSqr() < 0.01f * 0.01f) {
				isTooClose = true;
				break;
			}
		}

		if (isTooClose) {
			checkPts.erase(checkPts.begin() + i);
			i--;
		}
	}
}
```

Now, let’s talk about the AddPoint function. By all means this will be the most complicated part of this section. This is where we will have to loop over all triangles and determine if the point is on the positive side of the triangle, and if it is, delete the triangle. Then once all triangles are deleted, find the dangling edges and build new triangles:
```
bool IsEdgeUnique(const std::vector<Tri>& tris, const std::vector<int>& facingTris, const int ignoreTri, const Edge& edge)
{
	for (int i = 0; i < facingTris.size(); i++) {
		const int triIdx = facingTris[i];
		if (ignoreTri == triIdx) {
			continue;
		}

		const Tri& tri = tris[triIdx];

		Edge edges[3];
		edges[0].a = tri.a;
		edges[0].b = tri.b;

		edges[1].a = tri.b;
		edges[1].b = tri.c;

		edges[2].a = tri.c;
		edges[2].b = tri.a;

		for (int e = 0; e < 3; e++) {
			if (edge == edges[e]) {
				return false;
			}
		}
	}
	return true;
}

void AddPoint(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris, const Vec3& pt)
{
	// This point is outside
	// Now we need to remove old triangles and build new ones

	// Find all the triangles that face this point
	std::vector< int > facingTris;
	for (int i = (int)hullTris.size() - 1; i >= 0; i--) {
		const Tri& tri = hullTris[i];

		const Vec3& a = hullPoints[tri.a];
		const Vec3& b = hullPoints[tri.b];
		const Vec3& c = hullPoints[tri.c];

		const float dist = DistanceFromTriangle(a, b, c, pt);
		if (dist > 0.0f) {
			facingTris.push_back(i);
		}
	}

	// Now find all edges that are unique to the tris, these will be the edges that form the new triangles
	std::vector<Edge> uniqueEdges;
	for (int i = 0; i < facingTris.size(); i++) {
		const int triIdx = facingTris[i];
		const Tri& tri = hullTris[triIdx];

		Edge edges[3];
		edges[0].a = tri.a;
		edges[0].b = tri.b;

		edges[1].a = tri.b;
		edges[1].b = tri.c;

		edges[2].a = tri.c;
		edges[2].b = tri.a;

		for (int e = 0; e < 3; e++) {
			if (IsEdgeUnique(hullTris, facingTris, triIdx, edges[e])) {
				uniqueEdges.push_back(edges[e]);
			}
		}
	}

	// Now remove the old facing tris
	for (int i = 0; i < facingTris.size(); i++) {
		hullTris.erase(hullTris.begin() + facingTris[i]);
	}

	// Now add the new point
	hullPoints.push_back(pt);
	const int newPtIdx = (int)hullPoints.size() - 1;

	// Now add triangles for each unique edge
	for (int i = 0; i < uniqueEdges.size(); i++) {
		const Edge& edge = uniqueEdges[i];

		Tri tri;
		tri.a = edge.a;
		tri.b = edge.b;
		tri.c = newPtIdx;
		hullTris.push_back(tri);
	}
}
```

Finally, let’s talk about the RemoveUnreferencedVerts function. You may have noticed that when we removed triangles from the convex hull, that we didn’t remove the points that were referenced by the triangle. This is a really simple function, we only need to loop over each point and then check if it’s referenced by any triangles, if it isn’t, then we remove it.
```
void RemoveUnreferencedVerts(std::vector<Vec3>& hullPoints, std::vector<Tri>& hullTris)
{
	for (int i = 0; i < hullPoints.size(); i++) {

		bool isUsed = false;
		for (int j = 0; j < hullTris.size(); j++) {
			const Tri& tri = hullTris[j];

			if (tri.a == i || tri.b == i || tri.c == i) {
				isUsed = true;
				break;
			}
		}

		if (isUsed) {
			continue;
		}

		for (int j = 0; j < hullTris.size(); j++) {
			Tri& tri = hullTris[j];
			if (tri.a > i) {
				tri.a--;
			}
			if (tri.b > i) {
				tri.b--;
			}
			if (tri.c > i) {
				tri.c--;
			}
		}

		hullPoints.erase(hullPoints.begin() + i);
		i--;
	}
}
```

We can finally build the convex hull:
```
void BuildConvexHull(
	const std::vector<Vec3>& verts,
	std::vector<Vec3>& hullPts,
	std::vector<Tri>& hullTris
) {
	if (verts.size() < 4) {
		return;
	}

	// Build a tetrahedron
	BuildTetrahedron(verts.data(), (int)verts.size(), hullPts, hullTris);

	ExpandConvexHull(hullPts, hullTris, verts);
}
```

We’ve managed to take in a set of vertices, removed any vertices that are not on the surface of the convex hull, and built the list of triangles that composes the surface of the convex hull. The only thing we need to do now is build the inertia tensor for the shape. However, this is large enough of a topic, that we’ll do it in the next paragraph.

### Inertia tensor for convex hull

There’s a handful of ways we could go about calculating the inertia tensor for a convex hull. What we will do is perform a 3D integration over the bounds of the convex hull and if the sample point is outside the hull, we ignore it, but if it’s inside the hull then we treat it as a point mass and accumulate its moment of inertia. Recall that the definition of moment of inertia is:

$$ I_{ij} \equiv {\sum_{k} m_k \cdot (\vec{r_k} \cdot \vec{r_k} \cdot \delta_{ij} - x_i \cdot x_j)} $$

Where $\vec{r_i}$ is the distance from the center of mass for the sample point mass, $m_i$.

So, the first thing we need to do is calculate the center of mass. This will actually be a very similar algorithm to the inertia tensor, we’ll integrate over the bounds and only accumulate the sample points that are inside the convex hull. Recall that the center of mass is:

$$ x_{cm} = \frac {\sum_{i} x_i * m_i} {\sum_{i} m_i} $$

Let’s calculate the center of mass of the convex hull, then the inertia tensor:

`ShapeUtils.h`
```
bool IsExternal(const std::vector< Vec3 >& pts, const std::vector<Tri>& tris, const Vec3& pt)
{
	bool isExternal = false;
	for (int t = 0; t < tris.size(); t++) {
		const Tri& tri = tris[t];
		const Vec3& a = pts[tri.a];
		const Vec3& b = pts[tri.b];
		const Vec3& c = pts[tri.c];

		// If the point is in front of any triangle then it's external
		float dist = DistanceFromTriangle(a, b, c, pt);
		if (dist > 0.0f) {
			isExternal = true;
			break;
		}
	}

	return isExternal;
}
```

`Shape.h`
```
class ShapeConvex : public Shape
{
public:
	...

private:
	Vec3 CalculateCenterOfMass(const std::vector< Vec3 >& pts, const std::vector<Tri>& tris);
	Mat3 CalculateInertiaTensor(const std::vector< Vec3 >& pts, const std::vector<Tri>& tris, const Vec3& cm);
};
```

`Shape.cpp`
```
Vec3 ShapeConvex::CalculateCenterOfMass(const std::vector<Vec3>& pts, const std::vector<Tri>& tris)
{
	const int numSamples = 100;

	Bounds bounds;
	bounds.Expand(pts.data(), pts.size());

	Vec3 cm(0.0f);
	const float dx = bounds.WidthX() / (float)numSamples;
	const float dy = bounds.WidthY() / (float)numSamples;
	const float dz = bounds.WidthZ() / (float)numSamples;

	int sampleCount = 0;
	for (float x = bounds.mins.x; x < bounds.maxs.x; x += dx) {
		for (float y = bounds.mins.y; y < bounds.maxs.y; y += dy) {
			for (float z = bounds.mins.z; z < bounds.maxs.z; z += dz) {
				Vec3 pt(x, y, z);

				if (IsExternal(pts, tris, pt)) {
					continue;
				}

				cm += pt;
				sampleCount++;
			}
		}
	}

	cm /= (float)sampleCount;
	return cm;
}

Mat3 ShapeConvex::CalculateInertiaTensor(const std::vector<Vec3>& pts, const std::vector<Tri>& tris, const Vec3& cm)
{
	const int numSamples = 100;

	Bounds bounds;
	bounds.Expand(pts.data(), (int)pts.size());

	Mat3 tensor;
	tensor.Zero();

	const float dx = bounds.WidthX() / (float)numSamples;
	const float dy = bounds.WidthY() / (float)numSamples;
	const float dz = bounds.WidthZ() / (float)numSamples;

	int sampleCount = 0;
	for (float x = bounds.mins.x; x < bounds.maxs.x; x += dx) {
		for (float y = bounds.mins.y; y < bounds.maxs.y; y += dy) {
			for (float z = bounds.mins.z; z < bounds.maxs.z; z += dz) {
				Vec3 pt(x, y, z);

				if (IsExternal(pts, tris, pt)) {
					continue;
				}

				// Get the point relative to the center of mass
				pt -= cm;

				tensor.rows[0][0] += pt.y * pt.y + pt.z * pt.z;
				tensor.rows[1][1] += pt.z * pt.z + pt.x * pt.x;
				tensor.rows[2][2] += pt.x * pt.x + pt.y * pt.y;

				tensor.rows[0][1] += -1.0f * pt.x * pt.y;
				tensor.rows[0][2] += -1.0f * pt.x * pt.z;
				tensor.rows[1][2] += -1.0f * pt.y * pt.z;

				tensor.rows[1][0] += -1.0f * pt.x * pt.y;
				tensor.rows[2][0] += -1.0f * pt.x * pt.z;
				tensor.rows[2][1] += -1.0f * pt.y * pt.z;

				sampleCount++;
			}
		}
	}

	tensor *= 1.0f / (float)sampleCount;
	return tensor;
}
```

### Finalizing the convex hull

Now that we have a means of constructing a convex hull from a set of points and then calculating the center of mass and inertia tensor, we can finally put it all together. We’ve already done all the hard work. So the Build function for the convex shape turns into:

`Shape.cpp`
```
void ShapeConvex::Build(const Vec3* pts, const int num)
{
	points.clear();
	points.reserve(num);
	for (int i = 0; i < num; i++) {
		points.push_back(pts[i]);
	}

	// Expand into a convex hull
	std::vector<Vec3> hullPoints;
	std::vector<Tri> hullTriangles;
	BuildConvexHull(points, hullPoints, hullTriangles);
	points = hullPoints;

	// Expand the bounds
	bounds.Clear();
	bounds.Expand(points.data(), points.size());

	centerOfMass = CalculateCenterOfMass(hullPoints, hullTriangles);

	inertiaTensor = CalculateInertiaTensor(hullPoints, hullTriangles, centerOfMass);
}
```

Now we will replace the ground from the last lesson with a flat box shape, and then add some dynamic bodies. But first let’s go ahead and define the geometry for some new shapes we’ll be using.

Do not forget to uncomment the code in `Model::BuildFromShape(const Shape* shape)` (`model.cpp` file), so that the box and convex hull can be properly imported.

`Scene.cpp`
```
/*
========================================================================================================

Models

========================================================================================================
*/

static const float w = 50;
static const float h = 25;

Vec3 g_boxGround[] = {
	Vec3(-w,-h, 0),
	Vec3(w,-h, 0),
	Vec3(-w, h, 0),
	Vec3(w, h, 0),

	Vec3(-w,-h,-1),
	Vec3(w,-h,-1),
	Vec3(-w, h,-1),
	Vec3(w, h,-1),
};

Vec3 g_boxWall0[] = {
	Vec3(-1,-h, 0),
	Vec3(1,-h, 0),
	Vec3(-1, h, 0),
	Vec3(1, h, 0),

	Vec3(-1,-h, 5),
	Vec3(1,-h, 5),
	Vec3(-1, h, 5),
	Vec3(1, h, 5),
};

Vec3 g_boxWall1[] = {
	Vec3(-w,-1, 0),
	Vec3(w,-1, 0),
	Vec3(-w, 1, 0),
	Vec3(w, 1, 0),

	Vec3(-w,-1, 5),
	Vec3(w,-1, 5),
	Vec3(-w, 1, 5),
	Vec3(w, 1, 5),
};

Vec3 g_boxUnit[] = {
	Vec3(-1,-1,-1),
	Vec3(1,-1,-1),
	Vec3(-1, 1,-1),
	Vec3(1, 1,-1),

	Vec3(-1,-1, 1),
	Vec3(1,-1, 1),
	Vec3(-1, 1, 1),
	Vec3(1, 1, 1),
};

static const float t = 0.25f;
Vec3 g_boxSmall[] = {
	Vec3(-t,-t,-t),
	Vec3(t,-t,-t),
	Vec3(-t, t,-t),
	Vec3(t, t,-t),

	Vec3(-t,-t, t),
	Vec3(t,-t, t),
	Vec3(-t, t, t),
	Vec3(t, t, t),
};

static const float l = 3.0f;
Vec3 g_boxBeam[] = {
	Vec3(-l,-t,-t),
	Vec3(l,-t,-t),
	Vec3(-l, t,-t),
	Vec3(l, t,-t),

	Vec3(-l,-t, t),
	Vec3(l,-t, t),
	Vec3(-l, t, t),
	Vec3(l, t, t),
};

Vec3 g_boxPlatform[] = {
	Vec3(-l,-l,-t),
	Vec3(l,-l,-t),
	Vec3(-l, l,-t),
	Vec3(l, l,-t),

	Vec3(-l,-l, t),
	Vec3(l,-l, t),
	Vec3(-l, l, t),
	Vec3(l, l, t),
};

static const float t2 = 0.25f;
static const float w2 = t2 * 2.0f;
static const float h3 = t2 * 4.0f;
Vec3 g_boxBody[] = {
	Vec3(-t2,-w2,-h3),
	Vec3(t2,-w2,-h3),
	Vec3(-t2, w2,-h3),
	Vec3(t2, w2,-h3),

	Vec3(-t2,-w2, h3),
	Vec3(t2,-w2, h3),
	Vec3(-t2, w2, h3),
	Vec3(t2, w2, h3),
};

static const float h2 = 0.25f;
Vec3 g_boxLimb[] = {
	Vec3(-h3,-h2,-h2),
	Vec3(h3,-h2,-h2),
	Vec3(-h3, h2,-h2),
	Vec3(h3, h2,-h2),

	Vec3(-h3,-h2, h2),
	Vec3(h3,-h2, h2),
	Vec3(-h3, h2, h2),
	Vec3(h3, h2, h2),
};

Vec3 g_boxHead[] = {
	Vec3(-h2,-h2,-h2),
	Vec3(h2,-h2,-h2),
	Vec3(-h2, h2,-h2),
	Vec3(h2, h2,-h2),

	Vec3(-h2,-h2, h2),
	Vec3(h2,-h2, h2),
	Vec3(-h2, h2, h2),
	Vec3(h2, h2, h2),
};

Vec3 g_diamond[7 * 8];
void FillDiamond() {
	Vec3 pts[4 + 4];
	pts[0] = Vec3(0.1f, 0, -1);
	pts[1] = Vec3(1, 0, 0);
	pts[2] = Vec3(1, 0, 0.1f);
	pts[3] = Vec3(0.4f, 0, 0.4f);

	const float pi = acosf(-1.0f);
	const Quat quatHalf(Vec3(0, 0, 1), 2.0f * pi * 0.125f * 0.5f);
	pts[4] = Vec3(0.8f, 0, 0.3f);
	pts[4] = quatHalf.RotatePoint(pts[4]);
	pts[5] = quatHalf.RotatePoint(pts[1]);
	pts[6] = quatHalf.RotatePoint(pts[2]);

	const Quat quat(Vec3(0, 0, 1), 2.0f * pi * 0.125f);
	int idx = 0;
	for (int i = 0; i < 7; i++) {
		g_diamond[idx] = pts[i];
		idx++;
	}

	Quat quatAccumulator;
	for (int i = 1; i < 8; i++) {
		quatAccumulator = quatAccumulator * quat;
		for (int pt = 0; pt < 7; pt++) {
			g_diamond[idx] = quatAccumulator.RotatePoint(pts[pt]);
			idx++;
		}
	}
}

void AddStandardSandBox(std::vector<Body>& bodies) {
	Body body;

	body.position = Vec3(0, 0, 0);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity.Zero();
	body.angularVelocity.Zero();
	body.inverseMass = 0.0f;
	body.elasticity = 0.5f;
	body.friction = 0.5f;
	body.shape = new ShapeBox(g_boxGround, sizeof(g_boxGround) / sizeof(Vec3));
	bodies.push_back(body);

	body.position = Vec3(50, 0, 0);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity.Zero();
	body.angularVelocity.Zero();
	body.inverseMass = 0.0f;
	body.elasticity = 0.5f;
	body.friction = 0.0f;
	body.shape = new ShapeBox(g_boxWall0, sizeof(g_boxWall0) / sizeof(Vec3));
	bodies.push_back(body);

	body.position = Vec3(-50, 0, 0);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity.Zero();
	body.angularVelocity.Zero();
	body.inverseMass = 0.0f;
	body.elasticity = 0.5f;
	body.friction = 0.0f;
	body.shape = new ShapeBox(g_boxWall0, sizeof(g_boxWall0) / sizeof(Vec3));
	bodies.push_back(body);

	body.position = Vec3(0, 25, 0);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity.Zero();
	body.angularVelocity.Zero();
	body.inverseMass = 0.0f;
	body.elasticity = 0.5f;
	body.friction = 0.0f;
	body.shape = new ShapeBox(g_boxWall1, sizeof(g_boxWall1) / sizeof(Vec3));
	bodies.push_back(body);

	body.position = Vec3(0, -25, 0);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity.Zero();
	body.angularVelocity.Zero();
	body.inverseMass = 0.0f;
	body.elasticity = 0.5f;
	body.friction = 0.0f;
	body.shape = new ShapeBox(g_boxWall1, sizeof(g_boxWall1) / sizeof(Vec3));
	bodies.push_back(body);
}

...

/*
====================================================
Scene::Initialize
====================================================
*/
void Scene::Initialize() {
	Body body;

	body.position = Vec3(10, 0, 3);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity = Vec3(-100, 0, 0);
	body.angularVelocity = Vec3(0.0f, 0.0f, 0.0f);
	body.inverseMass = 1.0f;
	body.elasticity = 0.5f;
	body.friction = 0.5f;
	body.shape = new ShapeSphere(0.5f);
	bodies.push_back(body);

	AddStandardSandBox(bodies);
}
```

We have a method for creating general convex shapes. Unfortunately, we have yet to add any code that can check for collisions between convex shapes. That is what the next several paragraphs will be all about.

## Collisions with convex shapes

Here is a good introduction video for the concepts we will use : https://www.youtube.com/watch?v=ajv46BSqcK4

Here is a shorter version: https://www.youtube.com/watch?v=MDusDn8oTSE

### Minkowski sums

The Minkwoski sum is what happens when you have two sets of points A and B. And you add every point in A with every point in B:

$$ A + B = \lbrace a + b \mid a \in A, b \in B \rbrace $$

It’s important to note that the Minkowski sum of two convex sets, is itself a convex set. Why is that so important? Well, we already know it’s very easy to determine if a point is inside a convex hull. All that needs to be done is to check if the point is on the positive side of any face, if it is then it’s outside, if it isn’t then it’s inside.

This is going to be useful for determining if two convex hulls are overlapping. So how do we use this property to determine if two hulls are intersecting? Well, if we subtract every point in set B from every point in set A, then if they overlap, some of those points will map to the origin. This makes for a pretty trivial algorithm. Let’s review how it works:

1. Take the Minkowski “difference” between A and B ( $ A + -B $)
2. Check if the origin is contained by the new convex set

Now, you might be thinking that’s insane. Sure, the algorithm is simple. But building a convex hull, as we already know, is not exactly fast. And since we want to write a simulation that needs to run in real time, we need something slightly more efficient. This is where GJK enters : Gilbert-Johnson-Keerthi.

### Signed volumes

Before we actually get into the meat of the GJK algorithm, I’d like to go over an algorithm known as Signed Volumes. A key part of the GJK algorithm is the projection of the origin onto the 1, 2, or 3-simplex. The reason we need this, is because GJK needs to know the shortest distance/direction to the origin for any given simplex. And so, when we work on the GJK algorithm, it’d be nice if we already had this utility available.

Recall that the 1-simplex is a line segment, the 2-simplex is a triangle, and the 3-simplex is a tetrahedron. So, how do we go about projecting the origin onto those shapes? Or more generally, how do we project any point onto a simplex? The signed volumes approach is to find which axis-aligned plane maximizes the projected area or length of the simplex. So what does that mean? Well, let’s use a specific example.

Suppose we have a 1-simplex or line segment. We project it onto the x-axis, the y-axis, and the z-axis. Then, we determine which projection has the greatest length. We then choose that axis and project our point onto it as well. In this space, we can then easily calculate the barycentric coordinates of the point onto the 1-simplex. Which then gives us the projection of the point onto the 1-simplex.

```
     \
    | \
    |  \
    |   \
    |    \
    |     \
    |      |
    |      |
____|______|____
1-simplex projection
```

Here is the associated code:

`GJK.h`
```
int CompareSigns(float a, float b);

Vec2 SignedVolume1D(const Vec3& s1, const Vec3& s2);

Vec3 SignedVolume2D(const Vec3& s1, const Vec3& s2, const Vec3& s3);

Vec4 SignedVolume3D(const Vec3& s1, const Vec3& s2, const Vec3& s3, const Vec3& s4);

void TestSignedVolumeProjection();
```

`GJK.cpp`
```
int CompareSigns(float a, float b)
{
	if (a > 0.0f && b > 0.0f) {
		return 1;
	}
	if (a < 0.0f && b < 0.0f) {
		return 1;
	}
	return 0;
}

Vec2 SignedVolume1D(const Vec3& s1, const Vec3& s2)
{
	// Ray from a to b
	Vec3 ab = s2 - s1;
	// Ray from a to origin
	Vec3 ap = Vec3(0.0f) - s1;
	// Projection of the origin onto the line
	Vec3 p0 = s1 + ab * ab.Dot(ap) / ab.GetLengthSqr();

	// Choose the axis with the greatest difference/length
	int idx = 0;
	float mu_max = 0;
	for (int i = 0; i < 3; i++) {
		float mu = s2[i] - s1[i];
		if (mu * mu > mu_max * mu_max) {
			mu_max = mu;
			idx = i;
		}
	}

	// Project the simplex points and projected origin onto the axis with greatest length
	const float a = s1[idx];
	const float b = s2[idx];
	const float p = p0[idx];

	// Get the signed distance from a to p and from p to b
	const float C1 = p - a;
	const float C2 = b - p;

	// if p is between [a,b]
	if ((p > a && p < b) || (p > b && p < a)) {
		Vec2 lambdas;
		lambdas[0] = C2 / mu_max;
		lambdas[1] = C1 / mu_max;
		return lambdas;
	}

	// if p is on the far side of a
	if ((a <= b && p <= a) || (a >= b && p >= a)) {
		return Vec2(1.0f, 0.0f);
	}

	// p must be on the far side of b
	return Vec2(0.0f, 1.0f);
}
```

What about the 2-simplex or triangle? We do the same thing. Only we project the triangle onto the xy-plane, the yz-plane, and the zx-plane. Then we determine which projection has the greatest area. Then project the point onto that plane. If the point is inside the triangle, then calculate the barycentric coordinates and be done. If it’s outside the triangle, then project it onto the edges of the triangle using the 1-simplex projection method, and use the closest projection.

`GJK.cpp`
```
Vec3 normal = (s2 - s1).Cross(s3 - s1);
Vec3 p0 = normal * s1.Dot(normal) / normal.GetLengthSqr();

// Find the axis with the greatest projected area
int idx = 0;
float area_max = 0;
for (int i = 0; i < 3; i++) {
	int j = (i + 1) % 3;
	int k = (i + 2) % 3;

	Vec2 a = Vec2(s1[j], s1[k]);
	Vec2 b = Vec2(s2[j], s2[k]);
	Vec2 c = Vec2(s3[j], s3[k]);
	Vec2 ab = b - a;
	Vec2 ac = c - a;

	float area = ab.x * ac.y - ab.y * ac.x;
	if (area * area > area_max * area_max) {
		idx = i;
		area_max = area;
	}
}

// Project onto the appropriate axis
int x = (idx + 1) % 3;
int y = (idx + 2) % 3;
Vec2 s[3];
s[0] = Vec2(s1[x], s1[y]);
s[1] = Vec2(s2[x], s2[y]);
s[2] = Vec2(s3[x], s3[y]);
Vec2 p = Vec2(p0[x], p0[y]);

// Get the sub-areas of the triangles formed from the projected origin and the edges
Vec3 areas;
for (int i = 0; i < 3; i++) {
	int j = (i + 1) % 3;
	int k = (i + 2) % 3;

	Vec2 a = p;
	Vec2 b = s[j];
	Vec2 c = s[k];
	Vec2 ab = b - a;
	Vec2 ac = c - a;

	areas[i] = ab.x * ac.y - ab.y * ac.x;
}

// If the projected origin is inside the triangle, then return the barycentric points
if (CompareSigns(area_max, areas[0]) > 0 && CompareSigns(area_max, areas[1]) > 0 && CompareSigns(area_max, areas[2]) > 0) {
	Vec3 lambdas = areas / area_max;
	return lambdas;
}

// If we make it here, then we need to project onto the edges and determine the closest point
float dist = 1e10;
Vec3 lambdas = Vec3(1, 0, 0);
for (int i = 0; i < 3; i++) {
	int k = (i + 1) % 3;
	int l = (i + 2) % 3;

	Vec3 edgesPts[3];
	edgesPts[0] = s1;
	edgesPts[1] = s2;
	edgesPts[2] = s3;

	Vec2 lambdaEdge = SignedVolume1D(edgesPts[k], edgesPts[l]);
	Vec3 pt = edgesPts[k] * lambdaEdge[0] + edgesPts[l] * lambdaEdge[1];
	if (pt.GetLengthSqr() < dist) {
		dist = pt.GetLengthSqr();
		lambdas[i] = 0;
		lambdas[k] = lambdaEdge[0];
		lambdas[l] = lambdaEdge[1];
	}
}

return lambdas;
```

And finally we need to handle the 3-simplex case. Simply determine if the point is inside the tetrahedron, if it is then calculate its barycentric coordinates. If it isn’t, then check each face for which projection is closest.

`GJK.cpp`
```
Mat4 M;
M.rows[0] = Vec4(s1.x, s2.x, s3.x, s4.x);
M.rows[1] = Vec4(s1.y, s2.y, s3.y, s4.y);
M.rows[2] = Vec4(s1.z, s2.z, s3.z, s4.z);
M.rows[3] = Vec4(1.0f, 1.0f, 1.0f, 1.0f);

Vec4 C4;
C4[0] = M.Cofactor(3, 0);
C4[1] = M.Cofactor(3, 1);
C4[2] = M.Cofactor(3, 2);
C4[3] = M.Cofactor(3, 3);

const float detM = C4[0] + C4[1] + C4[2] + C4[3];

// If the barycentric coordinates put the origin inside the simplex, then return them
if (CompareSigns(detM, C4[0]) > 0 && CompareSigns(detM, C4[1]) > 0 && CompareSigns(detM, C4[2]) > 0 && CompareSigns(detM, C4[3]) > 0) {
	Vec4 lambdas = C4 * (1.0f / detM);
	return lambdas;
}

// If we get here, then we need to project the origin onto the faces and determine the closest one
Vec4 lambdas;
float dist = 1e10;
for (int i = 0; i < 4; i++) {
	int j = (i + 1) % 4;
	int k = (i + 2) % 4;

	Vec3 facePts[4];
	facePts[0] = s1;
	facePts[1] = s2;
	facePts[2] = s3;
	facePts[3] = s4;

	Vec3 lambdasFace = SignedVolume2D(facePts[i], facePts[j], facePts[k]);
	Vec3 pt = facePts[i] * lambdasFace[0] + facePts[j] * lambdasFace[1] + facePts[k] * lambdasFace[2];
	if (pt.GetLengthSqr() < dist) {
		dist = pt.GetLengthSqr();
		lambdas.Zero();
		lambdas[i] = lambdasFace[0];
		lambdas[j] = lambdasFace[1];
		lambdas[k] = lambdasFace[2];
	}
}

return lambdas;
```

Before we move on to the GJK algorithm. We should test these utiltiy functions to make sure they work as expected. Remember, they project a point onto the simplex and return the barycentric coordinates of the projection.
```
void TestSignedVolumeProjection() {
	const Vec3 orgPts[4] = {
		Vec3(0, 0, 0),
		Vec3(1, 0, 0),
		Vec3(0, 1, 0),
		Vec3(0, 0, 1),
	};
	Vec3 pts[4];
	Vec4 lambdas;
	Vec3 v;

	for (int i = 0; i < 4; i++) {
		pts[i] = orgPts[i] + Vec3(1, 1, 1);
	}
	lambdas = SignedVolume3D(pts[0], pts[1], pts[2], pts[3]);
	v.Zero();
	for (int i = 0; i < 4; i++) {
		v += pts[i] * lambdas[i];
	}
	printf("lambdas: %.3f %.3f %.3f %.3f        v: %.3f %.3f %.3f\n",
		lambdas.x, lambdas.y, lambdas.z, lambdas.w,
		v.x, v.y, v.z
	);

	for (int i = 0; i < 4; i++) {
		pts[i] = orgPts[i] + Vec3(-1, -1, -1) * 0.25f;
	}
	lambdas = SignedVolume3D(pts[0], pts[1], pts[2], pts[3]);
	v.Zero();
	for (int i = 0; i < 4; i++) {
		v += pts[i] * lambdas[i];
	}
	printf("lambdas: %.3f %.3f %.3f %.3f        v: %.3f %.3f %.3f\n",
		lambdas.x, lambdas.y, lambdas.z, lambdas.w,
		v.x, v.y, v.z
	);

	for (int i = 0; i < 4; i++) {
		pts[i] = orgPts[i] + Vec3(-1, -1, -1);
	}
	lambdas = SignedVolume3D(pts[0], pts[1], pts[2], pts[3]);
	v.Zero();
	for (int i = 0; i < 4; i++) {
		v += pts[i] * lambdas[i];
	}
	printf("lambdas: %.3f %.3f %.3f %.3f        v: %.3f %.3f %.3f\n",
		lambdas.x, lambdas.y, lambdas.z, lambdas.w,
		v.x, v.y, v.z
	);

	for (int i = 0; i < 4; i++) {
		pts[i] = orgPts[i] + Vec3(1, 1, -0.5f);
	}
	lambdas = SignedVolume3D(pts[0], pts[1], pts[2], pts[3]);
	v.Zero();
	for (int i = 0; i < 4; i++) {
		v += pts[i] * lambdas[i];
	}
	printf("lambdas: %.3f %.3f %.3f %.3f        v: %.3f %.3f %.3f\n",
		lambdas.x, lambdas.y, lambdas.z, lambdas.w,
		v.x, v.y, v.z
	);

	pts[0] = Vec3(51.1996613f, 26.1989613f, 1.91339576f);
	pts[1] = Vec3(-51.0567360f, -26.0565681f, -0.436143428f);
	pts[2] = Vec3(50.8978920f, -24.1035538f, -1.04042661f);
	pts[3] = Vec3(-49.1021080f, 25.8964462f, -1.04042661f);
	lambdas = SignedVolume3D(pts[0], pts[1], pts[2], pts[3]);
	v.Zero();
	for (int i = 0; i < 4; i++) {
		v += pts[i] * lambdas[i];
	}
	printf("lambdas: %.3f %.3f %.3f %.3f        v: %.3f %.3f %.3f\n",
		lambdas.x, lambdas.y, lambdas.z, lambdas.w,
		v.x, v.y, v.z
	);
}
```

### Gilbert-Johnson-Keerthi (GJK)

Recall that if we take the Minkowski ”difference” of two convex shapes then we can easily determine if they intersect.

Well, as it turns out, we don’t actually need to build the entire convex hull of the Minkowski “difference”. We only need to build the simplex that contains the origin. That significantly increases the performance when the objects intersect. But, when the objects don’t intersect, the algorithm will early out, so it’s even faster when there’s no intersection.

You may recall that when we built the convex hull from a set of points, we would first find a point that was furthest in a particular direction. It was mentioned that was called a support point. These support points become pretty vital to the GJK algorithm. So let’s go ahead and review the support functions in the shape classes:

`Shape.cpp`
```
Vec3 ShapeSphere::Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) const
{
	return pos + dir * (radius + bias);
}

Vec3 ShapeBox::Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) const
{
	// Find the point in furthest direction
	Vec3 maxPt = orient.RotatePoint(points[0]) + pos;
	float maxDist = dir.Dot(maxPt);
	for (int i = 1; i < points.size(); i++) {
		const Vec3 pt = orient.RotatePoint(points[i]) + pos;
		const float dist = dir.Dot(pt);

		if (dist > maxDist) {
			maxDist = dist;
			maxPt = pt;
		}
	}

	Vec3 norm = dir;
	norm.Normalize();
	norm *= bias;
	return maxPt + norm;
}

Vec3 ShapeConvex::Support(const Vec3& dir, const Vec3& pos, const Quat& orient, const float bias) const
{
	// Find the point in furthest in direction
	Vec3 maxPt = orient.RotatePoint(points[0]) + pos;
	float maxDist = dir.Dot(maxPt);
	for (int i = 1; i < points.size(); i++) {
		const Vec3 pt = orient.RotatePoint(points[i]) + pos;
		const float dist = dir.Dot(pt);

		if (dist > maxDist) {
			maxDist = dist;
			maxPt = pt;
		}
	}

	Vec3 norm = dir;
	norm.Normalize();
	norm *= bias;

	return maxPt + norm;
}
```

These functions take in a position and orientation, because the shape is defined in model/local space, but we’ll want the support point to be in world space. This function is very similar to the FindPointFurthestInDir function. But there’s a curious difference, the bias parameter. For right now, it’s not very important, as we’re just going to pass in zero. However, later it will become important and we’ll properly address it then.

You also may be curious why we added a support function for the sphere shape. And that’s because this algorithm works for all convex shapes. Not just convex hulls, but any and all convex shapes, you only have to define a support function to get it to work.

We don’t actually want to calculate this Minkowski sum, for it is an infinite task. We would rather find support points. So we start by getting a random support point on C (the minkowski difference). And we can do that by getting the support point on A and B then taking the difference, because that will be the support point on C. And the code for this is:

`GJK.h`
```
class Body;

struct Point
{
	// The point on the minkowski sum
	Vec3 xyz;

	// The point on bodyA
	Vec3 ptA;

	// The point on bodyB
	Vec3 ptB;

	Point() : xyz(0.0f), ptA(0.0f), ptB(0.0f) {}

	const Point& operator = (const Point& rhs) {
		xyz = rhs.xyz;
		ptA = rhs.ptA;
		ptB = rhs.ptB;
		return *this;
	}

	bool operator == (const Point& rhs) const {
		return ((ptA == rhs.ptA) && (ptB == rhs.ptB) && (xyz == rhs.xyz));
	}
};

Point Support(const Body* bodyA, const Body* bodyB, Vec3 dir, const float bias);
```

`GJK.cpp`
```
#include "Body.h"
#include "Shape.h"
...
Point Support(const Body* bodyA, const Body* bodyB, Vec3 dir, const float bias) {
	dir.Normalize();

	Point point;

	// Find the point in A furthest in direction
	point.ptA = bodyA->shape->Support(dir, bodyA->position, bodyA->orientation, bias);

	dir *= -1.0f;

	// Find the point in B furthest in the opposite direction
	point.ptB = bodyB->shape->Support(dir, bodyB->position, bodyB->orientation, bias);

	// Return the point, in the minkowski sum, furthest in the direction
	point.xyz = point.ptA - point.ptB;
	return point;
}
```

Quickly let’s talk about the Point struct. The reason it exists is because we want more than just the point on C, we also want the points on A and B that created it. This will be essential when we want to construct the contact between A and B. But we’ll get to that a little later.

So, now that we have a support point on C, we simply need another support point. But what direction do we choose? We choose the direction that points towards the origin with shortest distance. This will give us our next support point. Then, we need another support point, and again we choose the search direction by using the direction that points towards the origin with shortest distance. This gives the next support point.

Now, if the origin was inside the triangle (or 3-simplex), we’d be done. We’d know that the point was inside and therefore there’s an intersection. If it isn’t inside the triangle, then we need to throw away a support point and keep searching. We’d simply find which edge of the triangle has a normal that faces the origin, and throw away the other edges, then look for a support point in the normal direction of the remaining edge. Then we’d loop until either the 3-simplex contains the origin, or until we run out of new support points. If we never find a 3-simplex containing the origin, then there’s no intersection.

Extending this to full 3D isn’t too difficult, it just requires a few extra checks. We do the exact same thing, where we get the 0-simplex, then the 1-simplex, then the 2-simplex. Once we have the triangle (or 2-simplex), that’s where the algorithm diverges from the 2D example.

We simply use the normal of the triangle to determine which side of the triangle the origin is on. Then we use that normal (positive if the origin is on that side, negative if the origin is on the other side) to find a new support point and build the 3-simplex (tetrahedron). If the origin is inside the 3-simplex, then we’re done, the intersection occurs. If it isn’t, then just like before we have to search for a new support point. And then we continue looping until either the origin is inside the tetrahedron or we run out of new support points.

Okay that was a lot of text trying to describe what’s happening. So let’s review the algorithm:
1. Find any random support point.
2. Choose a new search direction (in this case, it’s the negative of the point’s position).
3. Find a new support point with the new search direction.
4. Check if we already have this support point. If we do, then we can’t expand any further. Return false.
5. Check if this new point is on the ”far” side of the origin from the simplex. If it’s on the ”same” side, then there’s no intersection. Return false.
6. Check if the origin is inside the simplex. If it is, return true. If it isn’t, then find a new search direction.
7. Check that the projection of the origin on the simplex is closer than the previous projection. If we’re not getting closer to the origin, there’s no intersection. Return false.
8. Remove any points from the simplex that do not support the projection of the origin onto the simplex.
9. If there’s four simplex points, then there’s an intersection. Return true. 10. Go to step 3.

Finally, putting this all in code form:

`GJK.h`
```
// Projects the origin onto the simplex to acquire the new search direction,
// also checks if the origin is "inside" the simplex.
bool SimplexSignedVolumes(Point* pts, const int num, Vec3& newDir, Vec4& lambdasOut);

// Checks whether the new point already exists in the simplex
bool HasPoint(const Point simplexPoints[4], const Point& newPt);

// Sorts the valid support points to the beginning of the array
void SortValids(Point simplexPoints[4], Vec4& lambdas);

static int NumValids(const Vec4& lambdas);

bool GJK_DoesIntersect(const Body* bodyA, const Body* bodyB);
```

`GJK.cpp`
```
bool SimplexSignedVolumes(Point* pts, const int num, Vec3& newDir, Vec4& lambdasOut)
{
	const float epsilonf = 0.0001f * 0.0001f;
	lambdasOut.Zero();

	bool doesIntersect = false;
	switch (num) {
	default:
	case 2: {
		Vec2 lambdas = SignedVolume1D(pts[0].xyz, pts[1].xyz);
		Vec3 v(0.0f);
		for (int i = 0; i < 2; i++) {
			v += pts[i].xyz * lambdas[i];
		}
		newDir = v * -1.0f;
		doesIntersect = (v.GetLengthSqr() < epsilonf);
		lambdasOut[0] = lambdas[0];
		lambdasOut[1] = lambdas[1];
	} break;
	case 3: {
		Vec3 lambdas = SignedVolume2D(pts[0].xyz, pts[1].xyz, pts[2].xyz);
		Vec3 v(0.0f);
		for (int i = 0; i < 3; i++) {
			v += pts[i].xyz * lambdas[i];
		}
		newDir = v * -1.0f;
		doesIntersect = (v.GetLengthSqr() < epsilonf);
		lambdasOut[0] = lambdas[0];
		lambdasOut[1] = lambdas[1];
		lambdasOut[2] = lambdas[2];
	} break;
	case 4: {
		Vec4 lambdas = SignedVolume3D(pts[0].xyz, pts[1].xyz, pts[2].xyz, pts[3].xyz);
		Vec3 v(0.0f);
		for (int i = 0; i < 4; i++) {
			v += pts[i].xyz * lambdas[i];
		}
		newDir = v * -1.0f;
		doesIntersect = (v.GetLengthSqr() < epsilonf);
		lambdasOut[0] = lambdas[0];
		lambdasOut[1] = lambdas[1];
		lambdasOut[2] = lambdas[2];
		lambdasOut[3] = lambdas[3];
	} break;
	};

	return doesIntersect;
}


bool HasPoint(const Point simplexPoints[4], const Point& newPt)
{
	const float precision = 1e-6f;

	for (int i = 0; i < 4; i++) {
		Vec3 delta = simplexPoints[i].xyz - newPt.xyz;
		if (delta.GetLengthSqr() < precision * precision) {
			return true;
		}
	}
	return false;
}


void SortValids(Point simplexPoints[4], Vec4& lambdas)
{
	bool valids[4];
	for (int i = 0; i < 4; i++) {
		valids[i] = true;
		if (lambdas[i] == 0.0f) {
			valids[i] = false;
		}
	}

	Vec4 validLambdas(0.0f);
	int validCount = 0;
	Point validPts[4];
	memset(validPts, 0, sizeof(Point) * 4);
	for (int i = 0; i < 4; i++) {
		if (valids[i]) {
			validPts[validCount] = simplexPoints[i];
			validLambdas[validCount] = lambdas[i];
			validCount++;
		}
	}

	// Copy the valids back into simplexPoints
	for (int i = 0; i < 4; i++) {
		simplexPoints[i] = validPts[i];
		lambdas[i] = validLambdas[i];
	}
}


static int NumValids(const Vec4& lambdas)
{
	int num = 0;
	for (int i = 0; i < 4; i++) {
		if (0.0f != lambdas[i]) {
			num++;
		}
	}
	return num;
}


bool GJK_DoesIntersect(const Body* bodyA, const Body* bodyB)
{
	const Vec3 origin(0.0f);

	int numPts = 1;
	Point simplexPoints[4];
	simplexPoints[0] = Support(bodyA, bodyB, Vec3(1, 1, 1), 0.0f);

	float closestDist = 1e10f;
	bool doesContainOrigin = false;
	Vec3 newDir = simplexPoints[0].xyz * -1.0f;
	do {
		// Get the new point to check on
		Point newPt = Support(bodyA, bodyB, newDir, 0.0f);

		// If the new point is the same as a previous point, then we can't expand any further
		if (HasPoint(simplexPoints, newPt)) {
			break;
		}

		simplexPoints[numPts] = newPt;
		numPts++;

		// If this new point hasn't moved passed the origin, then the
		// origin cannot be in the set. And therefore there is no collision.
		float dotdot = newDir.Dot(newPt.xyz - origin);
		if (dotdot < 0.0f) {
			break;
		}

		Vec4 lambdas;
		doesContainOrigin = SimplexSignedVolumes(simplexPoints, numPts, newDir, lambdas);
		if (doesContainOrigin) {
			break;
		}

		// Check that the new projection of the origin onto the simplex is closer than the previous
		float dist = newDir.GetLengthSqr();
		if (dist >= closestDist) {
			break;
		}
		closestDist = dist;

		// Use the lambdas that support the new search direction, and invalidate any points that don't support it
		SortValids(simplexPoints, lambdas);
		numPts = NumValids(lambdas);
		doesContainOrigin = (4 == numPts);
	} while (!doesContainOrigin);

	return doesContainOrigin;
}
```

Okay, this is an important algorithm. Take your time to examine it.

Something we neglected to mention before is why we need to check that the new projected point is closer to the origin than the previous projection. This is because of floating point errors. Imagine the convex hull of the minkowski difference (also known as Configuration Space Object or CSO). If the CSO has a face that’s a quad, then if the origin is close to the diagonal of the quad, then we can have a situation where we constantly flip between two different support points. Then we’ll end up looping forever. So, an easy check to prevent that is to make sure we’re always moving the simplex closer to the origin.

### Expanding polytope Algorith (EPA)

( Video explanation: https://www.youtube.com/watch?v=0XQ2FSz3EK8 )

So this is great. We have an algorithm that tells if two convex shapes intersect. But we need more than that. We need the contact point on A and the point on B and the contact normal between them. Otherwise we won’t be able to properly resolve the collision between the two bodies. How do we get that information?

It turns out that the point on the surface of the convex set C, that is closest to the origin, will give us the necessary information. That point, maps to the point on A and B of greatest penetration. And the direction from the origin to that point on C, gives the contact normal.

Now, is there an algorithm that we can exploit to find the surface point on C that is closest to the origin? Yes, and that is called the expanding polytope algorithm. Imagine we have the situation where we found a simplex that contains the origin, therefore we know there’s an intersection, but we don’t yet have any of the surfaces on C.

We just need to find the surface on C that is closest to the origin. To do this, we measure the distance from the origin to all sides of the simplex. Whichever surface of the simplex is closest, we throw that away, then we expand in the direction of the normal of that surface.

What we’re doing is building the convex hull of C, but we’re only interested in building the part that is closest to the origin. Once the closest surface can no longer be expanded further away from the origin, then we have the surface that is closest to the origin. And that surface will contain our contact point.

All we have to do now is cast a ray from the origin to the surface. Whatever point that is, is our contact point. We just need to calculate the barycentric points of the intersection with that face. Then use those to reconstruct the points on A and B.

Writing out the code for this, we get:

`GJK.h`
```
...
#include <vector>
struct Tri;
struct Edge;
...

// This borrows our signed volume code to perform the barycentric coordinates.
Vec3 BarycentricCoordinates(Vec3 s1, Vec3 s2, Vec3 s3, const Vec3& pt);

Vec3 NormalDirection(const Tri& tri, const std::vector< Point >& points);

float SignedDistanceToTriangle(const Tri& tri, const Vec3& pt, const std::vector<Point>& points);

int ClosestTriangle(const std::vector<Tri>& triangles, const std::vector<Point>& points);

bool HasPoint(const Vec3& w, const std::vector<Tri> triangles, const std::vector<Point>& points);

int RemoveTrianglesFacingPoint(const Vec3& pt, std::vector<Tri>& triangles, const std::vector<Point>& points);

void FindDanglingEdges(std::vector<Edge>& danglingEdges, const std::vector<Tri>& triangles);

float EPA_Expand(const Body* bodyA, const Body* bodyB, const float bias, const Point simplexPoints[4], Vec3& ptOnA, Vec3& ptOnB);
```

`GJK.cpp`
```
/*
================================================================================================

Expanding Polytope Algorithm

================================================================================================
*/

Vec3 BarycentricCoordinates(Vec3 s1, Vec3 s2, Vec3 s3, const Vec3& pt) {
	s1 = s1 - pt;
	s2 = s2 - pt;
	s3 = s3 - pt;

	Vec3 normal = (s2 - s1).Cross(s3 - s1);
	Vec3 p0 = normal * s1.Dot(normal) / normal.GetLengthSqr();

	// Find the axis with the greatest projected area
	int idx = 0;
	float area_max = 0;
	for (int i = 0; i < 3; i++) {
		int j = (i + 1) % 3;
		int k = (i + 2) % 3;

		Vec2 a = Vec2(s1[j], s1[k]);
		Vec2 b = Vec2(s2[j], s2[k]);
		Vec2 c = Vec2(s3[j], s3[k]);
		Vec2 ab = b - a;
		Vec2 ac = c - a;

		float area = ab.x * ac.y - ab.y * ac.x;
		if (area * area > area_max * area_max) {
			idx = i;
			area_max = area;
		}
	}

	// Project onto the appropriate axis
	int x = (idx + 1) % 3;
	int y = (idx + 2) % 3;
	Vec2 s[3];
	s[0] = Vec2(s1[x], s1[y]);
	s[1] = Vec2(s2[x], s2[y]);
	s[2] = Vec2(s3[x], s3[y]);
	Vec2 p = Vec2(p0[x], p0[y]);

	// Get the sub-areas of the triangles formed from the projected origin and the edges
	Vec3 areas;
	for (int i = 0; i < 3; i++) {
		int j = (i + 1) % 3;
		int k = (i + 2) % 3;

		Vec2 a = p;
		Vec2 b = s[j];
		Vec2 c = s[k];
		Vec2 ab = b - a;
		Vec2 ac = c - a;

		areas[i] = ab.x * ac.y - ab.y * ac.x;
	}

	Vec3 lambdas = areas / area_max;
	if (!lambdas.IsValid()) {
		lambdas = Vec3(1, 0, 0);
	}
	return lambdas;
}


Vec3 NormalDirection(const Tri& tri, const std::vector< Point >& points) {
	const Vec3& a = points[tri.a].xyz;
	const Vec3& b = points[tri.b].xyz;
	const Vec3& c = points[tri.c].xyz;

	Vec3 ab = b - a;
	Vec3 ac = c - a;
	Vec3 normal = ab.Cross(ac);
	normal.Normalize();
	return normal;
}


float SignedDistanceToTriangle(const Tri& tri, const Vec3& pt, const std::vector<Point>& points)
{
	const Vec3 normal = NormalDirection(tri, points);
	const Vec3& a = points[tri.a].xyz;
	const Vec3 a2pt = pt - a;
	const float dist = normal.Dot(a2pt);
	return dist;
}


int ClosestTriangle(const std::vector<Tri>& triangles, const std::vector<Point>& points)
{
	float minDistSqr = 1e10;

	int idx = -1;
	for (int i = 0; i < triangles.size(); i++) {
		const Tri& tri = triangles[i];

		float dist = SignedDistanceToTriangle(tri, Vec3(0.0f), points);
		float distSqr = dist * dist;
		if (distSqr < minDistSqr) {
			idx = i;
			minDistSqr = distSqr;
		}
	}

	return idx;
}


bool HasPoint(const Vec3& w, const std::vector< Tri > triangles, const std::vector< Point >& points) {
	const float epsilons = 0.001f * 0.001f;
	Vec3 delta;

	for (int i = 0; i < triangles.size(); i++) {
		const Tri& tri = triangles[i];

		delta = w - points[tri.a].xyz;
		if (delta.GetLengthSqr() < epsilons) {
			return true;
		}
		delta = w - points[tri.b].xyz;
		if (delta.GetLengthSqr() < epsilons) {
			return true;
		}
		delta = w - points[tri.c].xyz;
		if (delta.GetLengthSqr() < epsilons) {
			return true;
		}
	}
	return false;
}


int RemoveTrianglesFacingPoint(const Vec3& pt, std::vector<Tri>& triangles, const std::vector<Point>& points)
{
	int numRemoved = 0;
	for (int i = 0; i < triangles.size(); i++) {
		const Tri& tri = triangles[i];

		float dist = SignedDistanceToTriangle(tri, pt, points);
		if (dist > 0.0f) {
			// This triangle faces the point.  Remove it.
			triangles.erase(triangles.begin() + i);
			i--;
			numRemoved++;
		}
	}
	return numRemoved;
}


void FindDanglingEdges(std::vector<Edge>& danglingEdges, const std::vector<Tri>& triangles)
{
	danglingEdges.clear();

	for (int i = 0; i < triangles.size(); i++) {
		const Tri& tri = triangles[i];

		Edge edges[3];
		edges[0].a = tri.a;
		edges[0].b = tri.b;

		edges[1].a = tri.b;
		edges[1].b = tri.c;

		edges[2].a = tri.c;
		edges[2].b = tri.a;

		int counts[3];
		counts[0] = 0;
		counts[1] = 0;
		counts[2] = 0;

		for (int j = 0; j < triangles.size(); j++) {
			if (j == i) {
				continue;
			}

			const Tri& tri2 = triangles[j];

			Edge edges2[3];
			edges2[0].a = tri2.a;
			edges2[0].b = tri2.b;

			edges2[1].a = tri2.b;
			edges2[1].b = tri2.c;

			edges2[2].a = tri2.c;
			edges2[2].b = tri2.a;

			for (int k = 0; k < 3; k++) {
				if (edges[k] == edges2[0]) {
					counts[k]++;
				}
				if (edges[k] == edges2[1]) {
					counts[k]++;
				}
				if (edges[k] == edges2[2]) {
					counts[k]++;
				}
			}
		}

		// An edge that isn't shared, is dangling
		for (int k = 0; k < 3; k++) {
			if (0 == counts[k]) {
				danglingEdges.push_back(edges[k]);
			}
		}
	}
}


float EPA_Expand(const Body* bodyA, const Body* bodyB, const float bias, const Point simplexPoints[4], Vec3& ptOnA, Vec3& ptOnB) {
	std::vector< Point > points;
	std::vector< Tri > triangles;
	std::vector< Edge > danglingEdges;

	Vec3 center(0.0f);
	for (int i = 0; i < 4; i++) {
		points.push_back(simplexPoints[i]);
		center += simplexPoints[i].xyz;
	}
	center *= 0.25f;

	// Build the triangles
	for (int i = 0; i < 4; i++) {
		int j = (i + 1) % 4;
		int k = (i + 2) % 4;
		Tri tri;
		tri.a = i;
		tri.b = j;
		tri.c = k;

		int unusedPt = (i + 3) % 4;
		float dist = SignedDistanceToTriangle(tri, points[unusedPt].xyz, points);

		// The unused point is always on the negative/inside of the triangle.. make sure the normal points away
		if (dist > 0.0f) {
			std::swap(tri.a, tri.b);
		}

		triangles.push_back(tri);
	}

	//
	//	Expand the simplex to find the closest face of the CSO to the origin
	//
	while (1) {
		const int idx = ClosestTriangle(triangles, points);
		Vec3 normal = NormalDirection(triangles[idx], points);

		const Point newPt = Support(bodyA, bodyB, normal, bias);

		// if w already exists, then just stop
		// because it means we can't expand any further
		if (HasPoint(newPt.xyz, triangles, points)) {
			break;
		}

		float dist = SignedDistanceToTriangle(triangles[idx], newPt.xyz, points);
		if (dist <= 0.0f) {
			break;	// can't expand
		}

		const int newIdx = (int)points.size();
		points.push_back(newPt);

		// Remove Triangles that face this point
		int numRemoved = RemoveTrianglesFacingPoint(newPt.xyz, triangles, points);
		if (0 == numRemoved) {
			break;
		}

		// Find Dangling Edges
		danglingEdges.clear();
		FindDanglingEdges(danglingEdges, triangles);
		if (0 == danglingEdges.size()) {
			break;
		}

		// In theory the edges should be a proper CCW order
		// So we only need to add the new point as 'a' in order
		// to create new triangles that face away from origin
		for (int i = 0; i < danglingEdges.size(); i++) {
			const Edge& edge = danglingEdges[i];

			Tri triangle;
			triangle.a = newIdx;
			triangle.b = edge.b;
			triangle.c = edge.a;

			// Make sure it's oriented properly
			float dist = SignedDistanceToTriangle(triangle, center, points);
			if (dist > 0.0f) {
				std::swap(triangle.b, triangle.c);
			}

			triangles.push_back(triangle);
		}
	}

	// Get the projection of the origin on the closest triangle
	const int idx = ClosestTriangle(triangles, points);
	const Tri& tri = triangles[idx];
	Vec3 ptA_w = points[tri.a].xyz;
	Vec3 ptB_w = points[tri.b].xyz;
	Vec3 ptC_w = points[tri.c].xyz;
	Vec3 lambdas = BarycentricCoordinates(ptA_w, ptB_w, ptC_w, Vec3(0.0f));

	// Get the point on shape A
	Vec3 ptA_a = points[tri.a].ptA;
	Vec3 ptB_a = points[tri.b].ptA;
	Vec3 ptC_a = points[tri.c].ptA;
	ptOnA = ptA_a * lambdas[0] + ptB_a * lambdas[1] + ptC_a * lambdas[2];

	// Get the point on shape B
	Vec3 ptA_b = points[tri.a].ptB;
	Vec3 ptB_b = points[tri.b].ptB;
	Vec3 ptC_b = points[tri.c].ptB;
	ptOnB = ptA_b * lambdas[0] + ptB_b * lambdas[1] + ptC_b * lambdas[2];

	// Return the penetration distance
	Vec3 delta = ptOnB - ptOnA;
	return delta.GetMagnitude();
}
```

As you can see, we use the results from GJK to build the tetrahedron containing the origin. Then we just loop over all the surfaces, to expand in the direction of the closest surface.

Once we can no longer expand, we have the closest surface. You may recall that earlier we defined the struct point_t to contain the associated support points in A and B as well as the result in C. You can probably see why we did this now. Once we have the surface on C that’s closest to the origin, we use the barycentric coordinates to calculate the points on A and B.

Finally, we use the bias term. Why in the world do we use a bias here? The reason, is that if the two sets A and B are just barely touching, then the origin will be on the surface of C. This causes a problem for us. Since this will map the point on A and the point on B to be nearly the same point. And if those two points are too close to each other, then we can’t accurately calculate the contact normal. To curtail this problem, we simply use the bias to mildly expand the sets A and B. So when we first check if the two are overlapping, we expand them, then build the contact information. And this solves the problem of calculating an accurate contact normal.

This EPA function does need a full tetrahedron. Let’s go ahead and modify our GJK function to fully form the 3-simplex and then directly pass it into the EPA algorithm. This way we have a one stop function for both determining if an intersection happens and the calculating the contact points.

`GJK.h`
```
bool GJK_DoesIntersect(const Body* bodyA, const Body* bodyB, const float bias, Vec3& ptOnA, Vec3& ptOnB)
```

`GJK.cpp`
```
bool GJK_DoesIntersect(const Body* bodyA, const Body* bodyB, const float bias, Vec3& ptOnA, Vec3& ptOnB)
{
	const Vec3 origin(0.0f);

	int numPts = 1;
	Point simplexPoints[4];
	simplexPoints[0] = Support(bodyA, bodyB, Vec3(1, 1, 1), 0.0f);

	float closestDist = 1e10f;
	bool doesContainOrigin = false;
	Vec3 newDir = simplexPoints[0].xyz * -1.0f;
	do {
		// Get the new point to check on
		Point newPt = Support(bodyA, bodyB, newDir, 0.0f);

		// If the new point is the same as a previous point, then we can't expand any further
		if (HasPoint(simplexPoints, newPt)) {
			break;
		}

		simplexPoints[numPts] = newPt;
		numPts++;

		// If this new point hasn't moved passed the origin, then the
		// origin cannot be in the set. And therefore there is no collision.
		float dotdot = newDir.Dot(newPt.xyz - origin);
		if (dotdot < 0.0f) {
			break;
		}

		Vec4 lambdas;
		doesContainOrigin = SimplexSignedVolumes(simplexPoints, numPts, newDir, lambdas);
		if (doesContainOrigin) {
			break;
		}

		// Check that the new projection of the origin onto the simplex is closer than the previous
		float dist = newDir.GetLengthSqr();
		if (dist >= closestDist) {
			break;
		}
		closestDist = dist;

		// Use the lambdas that support the new search direction, and invalidate any points that don't support it
		SortValids(simplexPoints, lambdas);
		numPts = NumValids(lambdas);
		doesContainOrigin = (4 == numPts);
	} while (!doesContainOrigin);

	if (!doesContainOrigin) {
		return false;
	}

	//
	//	Check that we have a 3-simplex (EPA expects a tetrahedron)
	//
	if (1 == numPts) {
		Vec3 searchDir = simplexPoints[0].xyz * -1.0f;
		Point newPt = Support(bodyA, bodyB, searchDir, 0.0f);
		simplexPoints[numPts] = newPt;
		numPts++;
	}
	if (2 == numPts) {
		Vec3 ab = simplexPoints[1].xyz - simplexPoints[0].xyz;
		Vec3 u, v;
		ab.GetOrtho(u, v);

		Vec3 newDir = u;
		Point newPt = Support(bodyA, bodyB, newDir, 0.0f);
		simplexPoints[numPts] = newPt;
		numPts++;
	}
	if (3 == numPts) {
		Vec3 ab = simplexPoints[1].xyz - simplexPoints[0].xyz;
		Vec3 ac = simplexPoints[2].xyz - simplexPoints[0].xyz;
		Vec3 norm = ab.Cross(ac);

		Vec3 newDir = norm;
		Point newPt = Support(bodyA, bodyB, newDir, 0.0f);
		simplexPoints[numPts] = newPt;
		numPts++;
	}

	//
	// Expand the simplex by the bias amount
	//

	// Get the center point of the simplex
	Vec3 avg = Vec3(0, 0, 0);
	for (int i = 0; i < 4; i++) {
		avg += simplexPoints[i].xyz;
	}
	avg *= 0.25f;

	// Now expand the simplex by the bias amount
	for (int i = 0; i < numPts; i++) {
		Point& pt = simplexPoints[i];

		Vec3 dir = pt.xyz - avg;	// ray from "center" to witness point
		dir.Normalize();
		pt.ptA += dir * bias;
		pt.ptB -= dir * bias;
		pt.xyz = pt.ptA - pt.ptB;
	}

	//
	// Perform EPA expansion of the simplex to find the closest face on the CSO
	//
	EPA_Expand(bodyA, bodyB, bias, simplexPoints, ptOnA, ptOnB);
	return true;
}
```

### Closest point

Before we put all this together into our intersection tests. We’d like to discuss the closest points gjk algorithm.It’s going to turn out,  even when objects aren’t intersecting, it’s very useful to know the closest points on the two.

As you can probably guess, if we have the face on the surface of the CSO that’s closest to the origin, then even if there’s no intersection, we can use it to get the closest points. This modified GJK function will assume that there’s no intersection. That means we can remove a whole lot of early out checks. Because we actually just want to build and crawl the simplex until it can no longer get closer to the origin. Which makes its code simpler than the full GJK:

`GJK.h`
```
bool GJK_DoesIntersect(const Body* bodyA, const Body* bodyB, const float bias, Vec3& ptOnA, Vec3& ptOnB)
```

`GJK.cpp`
```
void GJK_ClosestPoints(const Body* bodyA, const Body* bodyB, Vec3& ptOnA, Vec3& ptOnB)
{
	const Vec3 origin(0.0f);

	float closestDist = 1e10f;
	const float bias = 0.0f;

	int numPts = 1;
	Point simplexPoints[4];
	simplexPoints[0] = Support(bodyA, bodyB, Vec3(1, 1, 1), bias);

	Vec4 lambdas = Vec4(1, 0, 0, 0);
	Vec3 newDir = simplexPoints[0].xyz * -1.0f;
	do {
		// Get the new point to check on
		Point newPt = Support(bodyA, bodyB, newDir, bias);

		// If the new point is the same as a previous point, then we can't expand any further
		if (HasPoint(simplexPoints, newPt)) {
			break;
		}

		// Add point and get new search direction
		simplexPoints[numPts] = newPt;
		numPts++;

		SimplexSignedVolumes(simplexPoints, numPts, newDir, lambdas);
		SortValids(simplexPoints, lambdas);
		numPts = NumValids(lambdas);

		// Check that the new projection of the origin onto the simplex is closer than the previous
		float dist = newDir.GetLengthSqr();
		if (dist >= closestDist) {
			break;
		}
		closestDist = dist;
	} while (numPts < 4);

	ptOnA.Zero();
	ptOnB.Zero();
	for (int i = 0; i < 4; i++) {
		ptOnA += simplexPoints[i].ptA * lambdas[i];
		ptOnB += simplexPoints[i].ptB * lambdas[i];
	}
}
```

## Physics with convex hull!

### Intersections

Now, we just need to update our intersection function, and we should be good to go. All we need is to check if the GJK returns true, and if it does, run the EPA:

`Ìntersections.h`
```
	static bool SphereSphereStatic(const ShapeSphere* sphereA, const ShapeSphere* sphereB,
		const Vec3& posA, const Vec3& posB, Vec3& ptOnA, Vec3& ptOnB);

	static bool Intersect(Body* a, Body* b, Contact& contact);
```

`Ìntersections.cpp`
```
bool SphereSphereStatic(const ShapeSphere* sphereA, const ShapeSphere* sphereB, const Vec3& posA, const Vec3& posB, Vec3& ptOnA, Vec3& ptOnB) {
	const Vec3 ab = posB - posA;
	Vec3 norm = ab;
	norm.Normalize();

	ptOnA = posA + norm * sphereA->radius;
	ptOnB = posB - norm * sphereB->radius;

	const float radiusAB = sphereA->radius + sphereB->radius;
	const float lengthSquare = ab.GetLengthSqr();
	if (lengthSquare <= (radiusAB * radiusAB)) {
		return true;
	}

	return false;
}


bool Intersect(Body* bodyA, Body* bodyB, Contact& contact) {
	contact.a = bodyA;
	contact.b = bodyB;
	contact.timeOfImpact = 0.0f;

	if (bodyA->shape->GetType() == Shape::ShapeType::SHAPE_SPHERE && bodyB->shape->GetType() == Shape::ShapeType::SHAPE_SPHERE) {
		const ShapeSphere* sphereA = (const ShapeSphere*)bodyA->shape;
		const ShapeSphere* sphereB = (const ShapeSphere*)bodyB->shape;

		Vec3 posA = bodyA->position;
		Vec3 posB = bodyB->position;

		if (SphereSphereStatic(sphereA, sphereB, posA, posB, contact.ptOnAWorldSpace, contact.ptOnBWorldSpace)) {
			contact.normal = posA - posB;
			contact.normal.Normalize();

			contact.ptOnALocalSpace = bodyA->WorldSpaceToBodySpace(contact.ptOnAWorldSpace);
			contact.ptOnBLocalSpace = bodyB->WorldSpaceToBodySpace(contact.ptOnBWorldSpace);

			Vec3 ab = bodyB->position - bodyA->position;
			float r = ab.GetMagnitude() - (sphereA->radius + sphereB->radius);
			contact.separationDistance = r;
			return true;
		}
	}
	else {
		Vec3 ptOnA;
		Vec3 ptOnB;
		const float bias = 0.001f;
		if (GJK_DoesIntersect(bodyA, bodyB, bias, ptOnA, ptOnB)) {
			// There was an intersection, so get the contact data
			Vec3 normal = ptOnB - ptOnA;
			normal.Normalize();

			ptOnA -= normal * bias;
			ptOnB += normal * bias;

			contact.normal = normal;

			contact.ptOnAWorldSpace = ptOnA;
			contact.ptOnBWorldSpace = ptOnB;

			contact.ptOnALocalSpace = bodyA->WorldSpaceToBodySpace(contact.ptOnAWorldSpace);
			contact.ptOnBLocalSpace = bodyB->WorldSpaceToBodySpace(contact.ptOnBWorldSpace);

			Vec3 ab = bodyB->position - bodyA->position;
			float r = (ptOnA - ptOnB).GetMagnitude();
			contact.separationDistance = -r;
			return true;
		}

		// There was no collision, but we still want the contact data, so get it
		GJK_ClosestPoints(bodyA, bodyB, ptOnA, ptOnB);
		contact.ptOnAWorldSpace = ptOnA;
		contact.ptOnBWorldSpace = ptOnB;

		contact.ptOnALocalSpace = bodyA->WorldSpaceToBodySpace(contact.ptOnAWorldSpace);
		contact.ptOnBLocalSpace = bodyB->WorldSpaceToBodySpace(contact.ptOnBWorldSpace);

		Vec3 ab = bodyB->position - bodyA->position;
		float r = (ptOnA - ptOnB).GetMagnitude();
		contact.separationDistance = r;
	}
	return false;
}
```

As you can see, we don’t throw away our sphere-sphere intersection test. Although GJK would work for sphere-sphere tests, the custom check is faster than GJK. In a production quality physics engine we would write a custom shape per shape collision check to get the fastest possible intersection tests (ie capsules, cylinders, etc would all get their own custom collision code). And we’d only use GJK when we don’t have a faster intersection test available.

Now, we only need to update our continuous collision detection algorithms. Then we can finally check if these objects will intersect.

### Continuous collision detection revised: Conservative Advance

It’s great that we finally have static collision between all of our shapes. However, we only have continuous collision for our spheres. We need to develop an algorithm for general convex shapes. Fortunately, there’s already an algorithm for this out there. It’s called **conservative advance**.

The algorithm is actually pretty simple. We simply find the closest distance between two objects, and then we calculate the fastest velocity on A and the fastest velocity on B, both projected onto the ray separating the two bodies. Using these velocities we can determine the minimum time required for the two shapes to come into contact. Then we just step the two bodies forward in time, and check for collision. If they collide, we’re done. If they don’t collide then we repeat this process until we’ve run out of time for the frame:

`GJK.h`
```
	static bool ConservativeAdvance(Body& bodyA, Body& bodyB, float dt, Contact& contact);
```

`GJK.cpp`
```
bool Intersections::ConservativeAdvance(Body& bodyA, Body& bodyB, float dt, Contact& contact)
{
	contact.a = &bodyA;
	contact.b = &bodyB;

	float toi = 0.0f;

	int numIters = 0;

	// Advance the positions of the bodies until they touch or there's not time left
	while (dt > 0.0f) {
		// Check for intersection
		bool didIntersect = Intersect(&bodyA, &bodyB, contact);
		if (didIntersect) {
			contact.timeOfImpact = toi;
			bodyA.Update(-toi);
			bodyB.Update(-toi);
			return true;
		}

		++numIters;
		if (numIters > 10) {
			break;
		}

		// Get the vector from the closest point on A to the closest point on B
		Vec3 ab = contact.ptOnBWorldSpace - contact.ptOnAWorldSpace;
		ab.Normalize();

		// project the relative velocity onto the ray of shortest distance
		Vec3 relativeVelocity = bodyA.linearVelocity - bodyB.linearVelocity;
		float orthoSpeed = relativeVelocity.Dot(ab);

		// Add to the orthoSpeed the maximum angular speeds of the relative shapes
		float angularSpeedA = bodyA.shape->FastestLinearSpeed(bodyA.angularVelocity, ab);
		float angularSpeedB = bodyB.shape->FastestLinearSpeed(bodyB.angularVelocity, ab * -1.0f);
		orthoSpeed += angularSpeedA + angularSpeedB;
		if (orthoSpeed <= 0.0f) {
			break;
		}

		float timeToGo = contact.separationDistance / orthoSpeed;
		if (timeToGo > dt) {
			break;
		}

		dt -= timeToGo;
		toi += timeToGo;
		bodyA.Update(timeToGo);
		bodyB.Update(timeToGo);
	}

	// Unwind the clock
	bodyA.Update(-toi);
	bodyB.Update(-toi);
	return false;
}
```

A quick note here is that we do have a max number of iterations. This is to avoid situations where the bodies rotate very quickly, but don’t translate. Because with high rates of rotation, we’ll sit here calculating tiny time steps, but then the bodies don’t actually move towards one another. So, to avoid sitting there looping forever, we put a limit on the number of iterations.

Now, let’s put it all together to finalize continuous collision detection for all shapes:

```
bool Intersections::Intersect(Body& a, Body& b, const float dt, Contact& contact)
{
	...
	if (a.shape->GetType() == Shape::ShapeType::SHAPE_SPHERE && b.shape->GetType() == Shape::ShapeType::SHAPE_SPHERE)
	{
		...
	}
	else
	{
		// Use GJK to perform conservative advancement
		bool result = ConservativeAdvance(a, b, dt, contact);
		return result;
	}
	...
}
```

### Let's test!

If you test your code now, you will see the ball colliding with the side of the box.

We will now add a diamond cponvex shape to test collisions with the sphere.

`application.cpp`
```
void Application::Initialize() {
	FillDiamond(); // UNCOMMENT
```

`Shape.h`
```
...
extern Vec3 g_diamond[7 * 8];
void FillDiamond();

class Shape
...
```

`Scene.cpp`
```
...
Vec3 g_diamond[7 * 8];
void FillDiamond()
{
	Vec3 pts[4 + 4];
	pts[0] = Vec3(0.1f, 0, -1);
	pts[1] = Vec3(1, 0, 0);
	pts[2] = Vec3(1, 0, 0.1f);
	pts[3] = Vec3(0.4f, 0, 0.4f);

	const float pi = acosf(-1.0f);
	const Quat quatHalf(Vec3(0, 0, 1), 2.0f * pi * 0.125f * 0.5f);
	pts[4] = Vec3(0.8f, 0, 0.3f);
	pts[4] = quatHalf.RotatePoint(pts[4]);
	pts[5] = quatHalf.RotatePoint(pts[1]);
	pts[6] = quatHalf.RotatePoint(pts[2]);

	const Quat quat(Vec3(0, 0, 1), 2.0f * pi * 0.125f);
	int idx = 0;
	for (int i = 0; i < 7; i++) {
		g_diamond[idx] = pts[i];
		idx++;
	}

	Quat quatAccumulator;
	for (int i = 1; i < 8; i++) {
		quatAccumulator = quatAccumulator * quat;
		for (int pt = 0; pt < 7; pt++) {
			g_diamond[idx] = quatAccumulator.RotatePoint(pts[pt]);
			idx++;
		}
	}
}

/*
========================================================================================================

Scene

========================================================================================================
*/
...
void Scene::Initialize() {
	Body body;

	body.position = Vec3(10, 0, 3);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity = Vec3(-100, 0, 0);
	body.angularVelocity = Vec3(0.0f, 0.0f, 0.0f);
	body.inverseMass = 1.0f;
	body.elasticity = 0.5f;
	body.friction = 0.5f;
	body.shape = new ShapeSphere(0.5f);
	bodies.push_back(body);

	body.position = Vec3(-10, 0, 3);
	body.orientation = Quat(0, 0, 0, 1);
	body.linearVelocity = Vec3(100, 0, 0);
	body.angularVelocity = Vec3(0, 10, 0);
	body.inverseMass = 1.0f;
	body.elasticity = 0.5f;
	body.friction = 0.5f;
	body.shape = new ShapeConvex(g_diamond, sizeof(g_diamond) / sizeof(Vec3));
	bodies.push_back(body);

	AddStandardSandBox(bodies);
}
...
```

Note the software screen can stay white for a long time while the diamond is filling.

Sphere and diamond will collide properly!